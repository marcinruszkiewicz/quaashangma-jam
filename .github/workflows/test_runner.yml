name: Test Runner
on:
  push:
    branches:
    - master
  pull_request:
    branches:
    - master

env:
  haxe-version: 4.2.5
  haxe-libs: heaps heaps-aseprite utest hashlink

jobs:
  test:
    strategy:
      fail-fast: false
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: "Setup Haxe"
        uses: actions/cache@v3
        with:
          path: ${{ runner.temp }}/haxe/sdk/haxe-${{ env.haxe-version }}
          key: ${{ runner.os }}-haxe-${{ env.haxe-version }}

      - name: "Setup Haxe: Install Binaries"
        shell: bash
        env:
          HAXE_HOME: ${{ runner.temp }}/haxe/sdk/haxe-${{ env.haxe-version }}
          HAXE_VERSION: ${{ env.haxe-version }}
        run: |
          echo "::group::Setup Haxe: Install Binaries"

          set -euo pipefail
          if [[ -n "${{ github.token }}" ]]; then
            auth_header='-H "Authorization: token ${{ github.token }}"'
          fi

          export PATH="$HAXE_HOME:$PATH"
          if [[ ! -f "$HAXE_HOME/haxe" ]]; then
            rm -rf "$HAXE_HOME"
            if [[ $HAXE_VERSION == 'latest' ]]; then
              archive_url=$(eval curl -sSfL ${auth_header:-} https://api.github.com/repos/HaxeFoundation/haxe/releases | grep -o "https://.*/download/.*/haxe.*-linux64.tar.gz" | head -n 1)
            elif [[ $HAXE_VERSION == 'nightly' ]]; then
              archive_url="https://build.haxe.org/builds/haxe/linux64/haxe_latest.tar.gz"
            else
              archive_url="https://github.com/HaxeFoundation/haxe/releases/download/${HAXE_VERSION}/haxe-${HAXE_VERSION}-linux64.tar.gz"
            fi
            mkdir -p "$HAXE_HOME"
            $(set -x; curl -sSfL $archive_url | tar -xz --strip-components=1 -C "$HAXE_HOME")
          fi
          echo "$HAXE_HOME" >> "$GITHUB_PATH"
          echo "HAXEPATH=$HAXE_HOME" | tee -a "$GITHUB_ENV"
          echo "HAXE_STD_PATH=$HAXE_HOME/std" | tee -a "$GITHUB_ENV"
          (set -x; haxelib setup $HAXE_HOME/lib)
          echo "::endgroup::"

      - name: "Setup Haxe: Verify PATH"
        shell: bash
        run: haxe -version # haxe 3 only supports -version. haxe 4 also --version

      - name: "Haxe Libs Cache: Restore"
        id: HAXE-LIBS-CACHE-RESTORE
        uses: actions/cache/restore@v3 # https://github.com/actions/cache/tree/main/restore
        with:
          path: |
            ${{ runner.tool_cache }}/haxe/lib
          # repo layout between haxe3 and 4 changed (and may change again) so we cache based on haxe version
          key: ${{ runner.os }}-haxelibs-${{ env.haxe-version }}

      - name: "Haxe Libs Cache: Init Root Path"
        id: HAXE-TARGETS-CACHE
        shell: bash
        run: |
          echo "::group::Haxe Libs Cache: Init Root Path"
          set -euo pipefail
          if [[ '${{ runner.os }}' == 'Windows' ]]; then
            path_nix="$(cygpath '${{ runner.tool_cache }}')/haxe/lib"
            echo 'path_win=${{ runner.tool_cache }}\haxe\lib' | tee -a "$GITHUB_OUTPUT"
          else
            path_nix='${{ runner.tool_cache }}/haxe/lib'
          fi
          mkdir -p "$path_nix"
          echo "path_nix=$path_nix" | tee -a "$GITHUB_OUTPUT"
          pushd "$path_nix"
            echo "initial_hash=$(find . -type f -printf "%p %s\n" | sort -z | sha1sum | cut -d' ' -f1)" | tee -a "$GITHUB_OUTPUT"
          popd
          ls -l $path_nix
          echo "::endgroup::"
      - name: "Install: Haxe Libraries"
        shell: bash
        run: |
          echo "::group::Install: Haxe Libraries"
          set -euo pipefail
          export HAXELIB_PATH='${{ runner.tool_cache }}/haxe/lib'
          mkdir -p "$HAXELIB_PATH"
          echo "HAXELIB_PATH=$HAXELIB_PATH" | tee -a "$GITHUB_ENV"
          haxelib config
          haxelibs='${{ env.haxe-libs }}'
          if [[ -n $haxelibs ]]; then
            # https://stackoverflow.com/a/1521470/5116073
            while read line || [[ -n $line ]]; do for lib in ${line%% #*}; do if [[ -n $lib ]]; then
              echo "::group::install_$lib"
              lib_name="${lib%%@*}"
              lib_ver="$(echo "$lib" | cut -s -d@ -f2)"

              # install from git
              if [[ $lib_ver == *://* ]]; then
                IFS='#' read -r -a lib_ver_splitted <<< "$lib_ver"

                # in case it was already loaded from cache, delete it to prevent git errors like "You have divergent branches and need to specify how to reconcile them."
                rm -rf "$HAXELIB_PATH/$lib_name/git"

                (set -x; haxelib git --always "$lib_name" "${lib_ver_splitted[0]}" ${lib_ver_splitted[1]:-}) || exit $?
                continue;
              fi

              # install from lib.haxe.org using curl instead of haxelib, which is faster and more robust
              pushd "$HOME"
                if [[ -z $lib_ver ]]; then
                  echo "Determining latest version of '${lib_name}'..."
                  lib_ver=$(curl -sSfL --max-time 5 --retry 3 -H "X-Haxe-Remoting: 1" \
                    "https://lib.haxe.org/api/3.0/index.n?__x=ay3:apiy16:getLatestVersionhay${#lib_name}:${lib_name}h" \
                  | cut -d: -f2)
                fi

                if [[ ! -f $HAXELIB_PATH/$lib_name/${lib_ver//./,}/haxelib.json ]]; then
                  (set -x; curl -sSfL --connect-timeout 10 --retry 3 "https://lib.haxe.org/p/$lib_name/$lib_ver/download/" -o "$lib_name.zip") || exit $?
                  (set -x; haxelib --always install "$lib_name.zip")
                  rm "$lib_name.zip"
                else
                  echo "Library $lib_name $lib_ver is already present."
                  (set -x; haxelib --always set "$lib_name" "$lib_ver")
                fi
              popd
              echo "::endgroup::"
            fi; done; done <<< "$haxelibs"
          fi
          echo "::endgroup::"


      ##################################################
      # Haxe Libs Cache Update
      # See https://github.com/actions/cache/issues/342
      ##################################################
      - name: "Haxe Libs Cache: Prepare Update"
        id: HAXE-LIBS-CACHE-UPDATE-PREPARE
        if: env.ACT != 'true' # https://github.com/nektos/act#skipping-steps
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          echo "::group::Haxe Targets Cache: Prepare Update"
            set -euo pipefail
            if [[ '${{ steps.HAXE-LIBS-CACHE-RESTORE.outputs.cache-hit }}' == "true" ]]; then
              pushd '${{ steps.haxe-targets.cache.outputs.path_nix }}'
                current_hash="$(find . -type f -printf "%p %s\n" | sort -z | sha1sum | cut -d' ' -f1)"
              popd
              if [[ "$current_hash" != '${{ steps.haxe-targets.cache.outputs.initial_hash }}' ]]; then
                echo "Cache update needed, since folder content changed. new hash: $current_hash"
                primaryCacheKey='${{ steps.HAXE-LIBS-CACHE-RESTORE.outputs.cache-primary-key }}'
                matchedCacheKey='${{ steps.HAXE-LIBS-CACHE-RESTORE.outputs.cache-matched-key }}'
                if [[ $primaryCacheKey == "$matchedCacheKey" ]]; then
                  gh extension install actions/gh-actions-cache || true
                  if gh actions-cache delete "$primaryCacheKey" --confirm; then
                    echo "need_cache_update=true" | tee -a "$GITHUB_OUTPUT"
                  fi
                else
                  echo "need_cache_update=true" | tee -a "$GITHUB_OUTPUT"
                fi
              else
                echo "No Cache update needed"
              fi
            else
              echo "Cache update needed, since no cache hit occured"
              echo "need_cache_update=true" | tee -a "$GITHUB_OUTPUT"
            fi
          echo "::endgroup::"
      - name: "Haxe Libs Cache: Update"
        uses: actions/cache/save@v3
        if: steps.HAXE-LIBS-CACHE-UPDATE-PREPARE.outputs.need_cache_update == 'true'
        with:
          path: |
            ${{ runner.tool_cache }}/haxe/lib
          key: ${{ steps.HAXE-LIBS-CACHE-RESTORE.outputs.cache-primary-key }}

      - name: "Run tests"
        run: haxe tests.hxml

